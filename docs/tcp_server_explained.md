# Blueprint for a Lineage 2 Login Server

This document provides a technical blueprint for creating a Lineage 2 login server from scratch. It's designed for developers who want to understand the core network protocol and implement it in any programming language. We'll use pseudo-code to explain the logic, focusing on the precise sequence of events for a successful client login.

## Core Concepts

Before diving into the implementation, let's cover three fundamental concepts of the L2 login protocol.

### 1. Packet Structure

All communication is based on packets. Each packet sent over the TCP socket follows a simple structure:

```
[Length (2 bytes, Little-Endian)] [Packet Data (variable size)]
```

- **Length**: An unsigned 16-bit integer that specifies the total size of the packet, *including the length field itself*.
- **Packet Data**: The actual payload of the packet. The content and structure of this data change depending on the context of the communication.

### 2. Connection State

A client connection is not static; it transitions through several states. The server must track the state of each connection to know how to handle incoming data.

1.  `CONNECTED`: The initial state after a TCP connection is established. No L2 packets have been exchanged.
2.  `INIT_SENT`: The server has sent the initial `Init` packet. It is now waiting for the client's first packet, which contains login credentials.
3.  `BLOWFISH_READY`: The first packet from the client has been received. All subsequent communication is now encrypted with Blowfish.

### 3. Cryptography

The login process uses two layers of encryption to secure the connection:

-   **RSA (1024-bit)**: Used asymmetrically for the very first data exchange. The server sends its public RSA key to the client, and the client uses it to encrypt the login credentials. This ensures that the username and password are never sent in plaintext.
-   **Blowfish**: A symmetric block cipher used for all communication *after* the initial credential exchange. The server generates a random Blowfish key and sends it to the client as part of the initial handshake.

---

## Step-by-Step Implementation

Let's walk through the entire process from a client connecting to a successful login.

### Step 1: Listening for Connections

First, you need a basic TCP server that listens on a port (the default for L2 is 2106) and accepts incoming connections.

```pseudocode
function start_server(host, port):
    server_socket = create_tcp_socket()
    bind(server_socket, host, port)
    listen(server_socket)

    // Pre-generate a pool of RSA key pairs for new connections
    rsa_key_pool = generate_rsa_key_pairs(count=10)

    while True:
        client_socket = accept(server_socket)
        // Handle each client in a new thread or asynchronously
        spawn_thread(handle_connection, client_socket, rsa_key_pool)
```

### Step 2: Sending the `Init` Packet (Unencrypted)

As soon as a client connects, the server must send the first packet: `Init`. This packet is critical as it contains the keys for the rest of the session.

**IMPORTANT**: The `Init` packet is sent **RAW**. It is **NOT** encrypted with Blowfish, and it does **NOT** have a checksum.

```pseudocode
function handle_connection(socket, rsa_key_pool):
    // 1. Get a fresh RSA key pair and generate a Blowfish key
    rsa_pair = rsa_key_pool.get_random_pair()
    blowfish_key = generate_random_bytes(16)

    // 2. Store these keys, associating them with the current connection
    connection.set_rsa_key(rsa_pair)
    connection.set_blowfish_key(blowfish_key)

    // 3. Construct the Init packet
    init_packet_data = create_init_packet(rsa_pair, blowfish_key)

    // 4. Prepend the 2-byte length header
    packet_to_send = prepend_length_header(init_packet_data)

    // 5. Send the raw bytes and update the state
    send(socket, packet_to_send)
    connection.set_state(INIT_SENT)

    // 6. Start listening for the client's response
    wait_for_client_packet(socket, connection)
```

The `Init` packet payload has a very specific structure:

| Field              | Type                | Size (bytes) | Description                                                              |
| ------------------ | ------------------- | ------------ | ------------------------------------------------------------------------ |
| Opcode             | `uint8`             | 1            | `0x00` for `Init`                                                        |
| Session ID         | `int32`             | 4            | A random 32-bit integer generated by the server.                         |
| Protocol Revision  | `int32`             | 4            | A hardcoded value, typically `0x0000c621`.                               |
| Scrambled RSA Mod. | `byte[]`            | 128          | The server's public RSA modulus, scrambled to make it harder to find.    |
| GameGuard Data     | `byte[]`            | 16           | A set of hardcoded "magic" constants required by the client.             |
| Blowfish Key       | `byte[]`            | 16           | The **unencrypted** Blowfish key for this session.                       |
| Null Terminator    | `uint8`             | 1            | A single null byte.                                                      |
| **Total Size**     |                     | **170**      |                                                                          |

### Step 3: Receiving Login Credentials (RSA-Encrypted)

After sending the `Init` packet, the server waits for the client to respond. The client's first packet will be `RequestAuthLogin`.

-   The packet's payload contains the username and password, **encrypted with the server's public RSA key**.
-   This packet is **NOT** encrypted with Blowfish. The server should read it as raw data.

```pseudocode
function wait_for_client_packet(socket, connection):
    // Read the 2-byte length, then the rest of the packet data
    raw_packet_data = read_packet(socket)

    // The first packet from the client must be processed raw.
    // After this, all communication becomes encrypted.
    if connection.get_state() == INIT_SENT:
        // Decrypt the payload using the connection's private RSA key
        decrypted_credentials = rsa_decrypt(raw_packet_data, connection.get_rsa_key().private)

        // Extract username and password from known offsets in the decrypted block
        username, password = parse_credentials(decrypted_credentials)

        // Authenticate the user
        is_valid = authenticate_user(username, password)

        // CRUCIAL: Enable Blowfish for all future packets
        connection.enable_blowfish_encryption()
        connection.set_state(BLOWFISH_READY)

        if is_valid:
            // Send LoginOk
            send_login_ok_packet(socket, connection)
        else:
            // Send LoginFail
            send_login_fail_packet(socket, connection)
```

### Step 4: Sending Encrypted Responses

From this point forward, every packet the server sends must be encrypted. Here is the process:

1.  Construct the packet payload (e.g., `LoginOk`).
2.  Append a 4-byte checksum of the payload.
3.  Add padding bytes (value `0x00`) so the total length is a multiple of 8 (a Blowfish requirement).
4.  Encrypt the entire buffer (payload + checksum + padding) using the session's Blowfish key.
5.  Prepend the 2-byte length header.
6.  Send the final packet.

```pseudocode
function send_encrypted_packet(socket, payload, blowfish_key):
    // 1. Append checksum
    data_with_checksum = append_checksum(payload)

    // 2. Add padding to be a multiple of 8
    padded_data = add_blowfish_padding(data_with_checksum)

    // 3. Encrypt with Blowfish
    encrypted_data = blowfish_encrypt(padded_data, blowfish_key)

    // 4. Prepend length and send
    packet_to_send = prepend_length_header(encrypted_data)
    send(socket, packet_to_send)
```

### Step 5: Handling Subsequent Encrypted Communication

All subsequent packets received from the client will also be Blowfish-encrypted and have a checksum. The server must reverse the process for sending:

1.  Read the packet (length header + encrypted data).
2.  Decrypt the data with Blowfish.
3.  Verify the checksum. If it fails, disconnect the client.
4.  Remove the padding and checksum.
5.  Process the clean packet payload.

This loop continues for the `RequestServerList` and `RequestServerLogin` flows, with all packets being encrypted and integrity-checked. 