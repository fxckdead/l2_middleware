# Blueprint for a Lineage 2 Login Server

This document provides a technical blueprint for creating a Lineage 2 login server from scratch. It's designed for developers who want to understand the core network protocol and implement it in any programming language. We'll use pseudo-code to explain the logic, focusing on the precise sequence of events for a successful client login.

## Core Concepts

Before diving into the implementation, let's cover three fundamental concepts of the L2 login protocol.

### 1. Packet Structure

All communication is based on packets. Each packet sent over the TCP socket follows a simple structure:

```
[Length (2 bytes, Little-Endian)] [Packet Data (variable size)]
```

- **Length**: An unsigned 16-bit integer that specifies the total size of the packet, *including the length field itself*.
- **Packet Data**: The actual payload of the packet. The content and structure of this data change depending on the context of the communication.

### 2. Connection State

A client connection is not static; it transitions through several states. The server must track the state of each connection to know how to handle incoming data.

1.  `CONNECTED`: The initial state after a TCP connection is established. No L2 packets have been exchanged.
2.  `INIT_SENT`: The server has sent the initial `Init` packet. It is now waiting for the client's first packet, which contains login credentials.
3.  `BLOWFISH_READY`: The first packet from the client has been received. All subsequent communication is now encrypted with Blowfish.

### 3. Cryptography

The login process uses two layers of encryption to secure the connection:

-   **RSA (1024-bit)**: Used asymmetrically for the very first data exchange. The server sends its public RSA key to the client, and the client uses it to encrypt the login credentials. This ensures that the username and password are never sent in plaintext.
-   **Blowfish**: A symmetric block cipher used for all communication *after* the initial credential exchange. The server generates a random Blowfish key and sends it to the client as part of the initial handshake.

---

## Step-by-Step Implementation

Let's walk through the entire process from a client connecting to a successful login.

### Step 1: Listening for Connections

First, you need a basic TCP server that listens on a port (the default for L2 is 2106) and accepts incoming connections.

```pseudocode
function start_server(host, port):
    server_socket = create_tcp_socket()
    bind(server_socket, host, port)
    listen(server_socket)

    // Pre-generate a pool of RSA key pairs for new connections
    rsa_key_pool = generate_rsa_key_pairs(count=10)

    while True:
        client_socket = accept(server_socket)
        // Handle each client in a new thread or asynchronously
        spawn_thread(handle_connection, client_socket, rsa_key_pool)
```

### Step 2: Sending the `Init` Packet (Unencrypted)

As soon as a client connects, the server must send the first packet: `Init`. This packet is critical as it contains the keys for the rest of the session.

**IMPORTANT**: The `Init` packet is sent **RAW**. It is **NOT** encrypted with Blowfish, and it does **NOT** have a checksum.

```pseudocode
function handle_connection(socket, rsa_key_pool):
    // 1. Get a fresh RSA key pair and generate a Blowfish key
    rsa_pair = rsa_key_pool.get_random_pair()
    blowfish_key = generate_random_bytes(16)

    // 2. Store these keys, associating them with the current connection
    connection.set_rsa_key(rsa_pair)
    connection.set_blowfish_key(blowfish_key)

    // 3. Construct the Init packet
    init_packet_data = create_init_packet(rsa_pair, blowfish_key)

    // 4. Prepend the 2-byte length header
    packet_to_send = prepend_length_header(init_packet_data)

    // 5. Send the raw bytes and update the state
    send(socket, packet_to_send)
    connection.set_state(INIT_SENT)

    // 6. Start listening for the client's response
    wait_for_client_packet(socket, connection)
```

The `Init` packet payload has a very specific structure:

| Field              | Type                | Size (bytes) | Description                                                              |
| ------------------ | ------------------- | ------------ | ------------------------------------------------------------------------ |
| Opcode             | `uint8`             | 1            | `0x00` for `Init`                                                        |
| Session ID         | `int32`             | 4            | A random 32-bit integer generated by the server.                         |
| Protocol Revision  | `int32`             | 4            | A hardcoded value, typically `0x0000c621`.                               |
| Scrambled RSA Mod. | `byte[]`            | 128          | The server's public RSA modulus, scrambled to make it harder to find.    |
| GameGuard Data     | `byte[]`            | 16           | A set of hardcoded "magic" constants required by the client.             |
| Blowfish Key       | `byte[]`            | 16           | The **unencrypted** Blowfish key for this session.                       |
| Null Terminator    | `uint8`             | 1            | A single null byte.                                                      |
| **Total Size**     |                     | **170**      |                                                                          |

### Step 3: Receiving Login Credentials (RSA-Encrypted)

After sending the `Init` packet, the server waits for the client to respond. The client's first packet will be `RequestAuthLogin`.

-   The packet's payload contains the username and password, **encrypted with the server's public RSA key**.
-   This packet is **NOT** encrypted with Blowfish. The server should read it as raw data.

```pseudocode
function wait_for_client_packet(socket, connection):
    // Read the 2-byte length, then the rest of the packet data
    raw_packet_data = read_packet(socket)

    // The first packet from the client must be processed raw.
    // After this, all communication becomes encrypted.
    if connection.get_state() == INIT_SENT:
        // Decrypt the payload using the connection's private RSA key
        decrypted_credentials = rsa_decrypt(raw_packet_data, connection.get_rsa_key().private)

        // Extract username and password from known offsets in the decrypted block
        username, password = parse_credentials(decrypted_credentials)

        // Authenticate the user
        is_valid = authenticate_user(username, password)

        // CRUCIAL: Enable Blowfish for all future packets
        connection.enable_blowfish_encryption()
        connection.set_state(BLOWFISH_READY)

        if is_valid:
            // Send LoginOk
            send_login_ok_packet(socket, connection)
        else:
            // Send LoginFail
            send_login_fail_packet(socket, connection)
```

### Step 4: Sending Encrypted Responses

From this point forward, every packet the server sends must be encrypted. Here is the process:

1.  Construct the packet payload (e.g., `LoginOk`).
2.  Append a 4-byte checksum of the payload.
3.  Add padding bytes (value `0x00`) so the total length is a multiple of 8 (a Blowfish requirement).
4.  Encrypt the entire buffer (payload + checksum + padding) using the session's Blowfish key.
5.  Prepend the 2-byte length header.
6.  Send the final packet.

```pseudocode
function send_encrypted_packet(socket, payload, blowfish_key):
    // 1. Append checksum
    data_with_checksum = append_checksum(payload)

    // 2. Add padding to be a multiple of 8
    padded_data = add_blowfish_padding(data_with_checksum)

    // 3. Encrypt with Blowfish
    encrypted_data = blowfish_encrypt(padded_data, blowfish_key)

    // 4. Prepend length and send
    packet_to_send = prepend_length_header(encrypted_data)
    send(socket, packet_to_send)
```

### Step 5: Handling Subsequent Encrypted Communication

All subsequent packets received from the client will also be Blowfish-encrypted and have a checksum. The server must reverse the process for sending:

1.  Read the packet (length header + encrypted data).
2.  Decrypt the data with Blowfish.
3.  Verify the checksum. If it fails, disconnect the client.
4.  Remove the padding and checksum.
5.  Process the clean packet payload.

This loop continues for the `RequestServerList` and `RequestServerLogin` flows, with all packets being encrypted and integrity-checked. 

---

# Blueprint for a Lineage 2 **Game Server** (Interlude 746)

The login phase is now complete and the client connects to the **game server** (default port 7777).  The game-server protocol re-uses the same 2-byte length header, but the handshake and encryption rules are different.

## 1. Packet Structure Recap

```
[Length (2 bytes, LE)] [Packet Data]
```

* **Length** — includes the 2-byte header
* **Packet Data** — encrypted _after_ the first two packets

For **patched Interlude clients** the game server uses an XOR stream cipher (the same algorithm retail clients used for pre-C4 chronicles).  Retail-like clients expect Blowfish.  We therefore:

* Send the initial key **in plaintext** inside `VersionCheck`
* Enable **XOR** immediately after sending that packet
* Keep the ability to switch to Blowfish later via a server flag

### Padding rules

| Cipher | Check-sum | Padding rule |
| -------|-----------|--------------|
| XOR    | 4-byte CRC | Pad to 4-byte boundary |
| Blowfish | 4-byte CRC | Pad to 8-byte boundary |

## 2. Minimal Handshake Flow

```
Client → 0x00 SendProtocolVersion   (plain-text)
Server ← 0x00 VersionCheck          (27 bytes, plain-text)
Client → 0x08 RequestLogin          (encrypted)
Server ← 0xDE ShowTownMap (test) or 0x13 CharacterSelectionInfo (encrypted)
```

### 2.1  SendProtocolVersion  (client ⇒ server)

```
opcode   = 0x00
protocol = 746               # Interlude Update 3
```

### 2.2  VersionCheck  (server ⇒ client)

The server answers with **exactly 27 bytes** (plus the 2-byte length header).

| Offset | Size | Value                        | Notes |
|--------|------|------------------------------|-------|
| 0      | 1    | `0x00`                       | Opcode |
| 1      | 1    | `0x01`                       | Protocol accepted flag |
| 2      | 16   | `blowfish_or_xor_key[16]`    | Session key sent in plain-text |
| 18     | 4    | `0x00000000`                 | Opcode obfuscation key (unused) |
| 22     | 4    | `0x00000300`                 | Feature flags — 0x0300 ⇒ GG-off, legacy mode |
| 26     | 1    | `0x00`                       | Reserved |

Immediately after this packet is flushed you **enable the XOR cipher**:

```pseudocode
cipher = GameClientXOR(key)
cipher.enable()    // first encrypted packet is next
```

## 3. XOR Encryption / Decryption

```pseudocode
class GameClientXOR:
    def __init__(self, key_16_bytes):
        self.in_key  = key_16_bytes.copy()
        self.out_key = key_16_bytes.copy()
        self.enabled = False

    def enable(self):
        self.enabled = True

    def decrypt(self, data):
        if not self.enabled:
            self.enabled = True   # first packet is plain-text
            return data           # no changes
        x_or = 0
        for i, byte in enumerate(data):
            enc = byte
            data[i] ^= self.in_key[i & 0x0F] ^ x_or
            x_or = enc
        # rotate key
        block = little_endian_u32(self.in_key[8:12]) + len(data)
        self.in_key[8:12] = u32_to_bytes(block)
        return data
```

*Encryption* is symmetric (see full implementation in `src/core/encryption/game_client_encryption.cpp`).

## 4. Handling RequestLogin (0x08)

`RequestLogin` arrives encrypted.  After decrypting you must read the full buffer so no stray bytes remain; otherwise the next byte will be mis-interpreted as a bogus opcode.

```pseudocode
struct RequestLogin {
    opcode       = 0x08
    account      = read_c_utf16le()    // "hola" in our test
    play_ok2     = read_u32()
    play_ok1     = read_u32()
    login_ok1    = read_u32()
    login_ok2    = read_u32()
    client_rev   = read_u32()          // protocol version repeated
}
```

Validate the four integers against what the Login-server issued.  On success:

```pseudocode
send(CharacterSelectionInfo(...))   // opcode 0x13, encrypted
```

## 5. Building Encrypted Replies

```pseudocode
def send_game_packet(conn, payload):
    L2Checksum.add_crc(payload)        # 4-byte XOR CRC
    pad(payload, 4 if conn.xor else 8)
    encrypted = conn.cipher.encrypt(payload)
    final = add_length_header(encrypted)
    socket.send(final)
```

---

## Checklist for Your Own Emulator

- [x] Plain-text 27-byte VersionCheck
- [x] Enable XOR right after sending it
- [ ] Full `AuthLoginPacket` reader & key validation
- [ ] XOR CRC verification on incoming packets
- [ ] Real `CharacterSelectionInfo` data
- [ ] Additional opcodes (EnterWorld, Move, Chat…)

Once these are in place the client should enter the character selection screen and, after choosing a character, request to enter the world. 